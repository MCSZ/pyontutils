@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix xml: <http://www.w3.org/XML/1998/namespace> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix blx: <http://uri.binterlex.org/base/> .
@prefix BLX: <http://uri.binterlex.org/base/blx_> .  # test for longest prefix wins
@prefix other: <http://FIXME.org/other_> .
@prefix A: <http://Z.org/prefix_> .
@prefix B: <http://X.org/prefix_> .
@prefix requestedBy: <http://uri.binterlex.org/base/blx_999> . #make sure we can manage prefixes that are full uris

<http://testurl.org/filename.ttl> a owl:Ontology ;
    rdfs:label "U WOT M8" .

# test annotation properties
requestedBy: a owl:AnnotationProperty .

# test full uri shortening
BLX:BB a owl:Class ;
    <http://uri.binterlex.org/base/blx_999> "DIO!" .

# test consistent ordering with respect to case
BLX:AA a owl:Class .
blx:aa a owl:Class .
blx:Aa a owl:Class .
BLX:Aa a owl:Class .
blx:AA a owl:Class .
BLX:aa a owl:Class .
blx:aA a owl:Class .
BLX:aA a owl:Class .

# test qnames where the fragment is only numbers
BLX:1234567 a owl:Class .
blx:1234567 a owl:Class .

# test generating qnames from iris
<http://uri.binterlex.org/base/123> a owl:Class .
<http://uri.binterlex.org/base/blx_123> a owl:Class .

# test ordering of multiple restrictions
BLX:2 a owl:Class ;
    rdfs:subClassOf BLX:1234567,
        [ a owl:Restriction ;
            owl:onProperty other:b1 ;
            owl:allValuesFrom other:4 ],
        [ a owl:Restriction ;
            owl:onProperty other:b1 ;
            owl:allValuesFrom other:3 ],
        [ a owl:Restriction ;
            owl:onProperty other:b1 ;
            owl:someValuesFrom other:6 ],
        [ a owl:Restriction ;
            owl:onProperty other:b1 ;
            owl:someValuesFrom other:5 ],
        [ a owl:Restriction ;
            owl:onProperty other:a1 ;
            owl:someValuesFrom other:2 ],
        [ a owl:Restriction ;
            owl:onProperty other:a1 ;
            owl:someValuesFrom other:1 ] .

# test whether restrictions flip

BLX:0 a owl:Class ;
    rdfs:subClassOf BLX:1234567,
        [ a owl:Restriction ;
            owl:onProperty other:b1 ;
            owl:allValuesFrom other:2 ],
        [ a owl:Restriction ;
            owl:onProperty other:b1 ;
            owl:someValuesFrom other:2 ] .

# test whether classes can flip (the actual construction is nonsense, and not valid owl...)
BLX:0.5 a owl:Class ;
    rdfs:subClassOf BLX:1234567,
        [ a owl:Restriction ;
            owl:onProperty other:b1 ;
            owl:someValuesFrom other:2 ],
        [ a owl:Class ;
            owl:onProperty other:b1 ;
            owl:someValuesFrom other:2 ] .

# test that we are ordering classes based on their qname not their uri
B:1 a owl:Class .
A:1 a owl:Class .

BLX:1 a owl:Class ;
    rdfs:subClassOf B:1, A:1 .

# test ordering of rdf:List
BLX:3 a owl:Class ;
    owl:disjointUnionOf ( BLX:AA BLX:aA blx:aa blx:Aa B:5 B:4 B:3 B:2 B:1 A:5 A:4 A:3 A:2 A:1 ) .

# test conversion of unpacked lists to correct representation
BLX:4 a owl:Class ;
    owl:disjointUnionOf [ rdf:first B:1 ;
        rdf:rest [ rdf:first A:2 ;
            rdf:rest [ rdf:first A:1 ;
                rdf:rest rdf:nil ] ] ] .

# test conversion of unpacked lists with explitic rdf:List
BLX:4.5 a owl:Class ;
    owl:disjointUnionOf [ a rdf:List ;
        rdf:first B:1 ;
        rdf:rest [ a rdf:List ;
            rdf:first A:2 ;
            rdf:rest [ a rdf:List ;
                rdf:first A:1 ;
                rdf:rest rdf:nil ] ] ] .

# test booleans in list
BLX:5 a owl:Class ;
    owl:oneOf [ rdf:first "true"^^xsd:boolean ;
                rdf:rest [ rdf:first "false"^^xsd:boolean ;
                    rdf:rest rdf:nil ] ] .

# make sure rdfs:Datatype is not pulled out to the top level
BLX:6 a owl:Class ;
    rdfs:range [ a rdfs:Datatype ;
        owl:oneOf ( A:1 A:2 A:3 ) ] .

# general axioms tests
[ rdf:type owl:AllDifferent ;  # this should appear further down the page
    owl:distinctMembers ( A:0 A:prefix_1 A:prefix_2 A:prefix_3 A:1 A:2 A:3 ) ] .

[ rdf:type owl:AllDifferent ;  # this should appear above the general axiom above
    owl:distinctMembers ( A:prefix_4 A:prefix_5 A:prefix_6 A:4 A:5 A:6 ) ] .

# test the effect of types on strings
BLX:7 a owl:Class ;
    rdfs:label "label1", "label1"^^xsd:string, "label1"@en .

# test for literal ordering
BLX:8 a owl:Class ;
    rdfs:label "Label2", "label2" .
